# 通知中心 - 设计文档

## 架构概览
- **统一入口**：NotifyController，提供 REST + WebSocket/SSE。
- **模板与通道路由**：NotifyService 根据通知类型选择通道（站内信/邮件/短信/WebSocket），渲染模板。
- **存储**：MySQL `notify_message`（id,user_id,type,title,content,status,action_url,channel,created_at,read_at），Redis 用于未读计数与用户订阅信息。
- **异步发送**：消息入队（`notify.topic`），由 Sender Worker 异步下发；失败入死信队列并可重试。

## 通道设计
- **站内信**：写入 DB，并在 Redis 维护未读计数（key: `notify:unread:{userId}`）。
- **WebSocket/SSE**：使用 `spring-websocket` 或 SSE，维护连接表；推送时若用户不在线则写未送达表并触发邮件兜底。
- **邮件/短信**：基于现有邮件服务；短信可预留 Provider 接口，按配置开关。

## 接口与字段
- `GET /api/notify/unread-count`：读 Redis 未读计数，未命中回源 DB 并回填。
- `GET /api/notify/list`：分页查询用户消息表，支持类型过滤；结果附 `actionUrl` 供前端跳转。
- `POST /api/notify/read`：批量更新 DB `status=READ`，同步减 Redis 未读计数。
- `POST /api/notify/read-all`：DB 全量更新 + Redis 删除未读 key。
- `POST /api/notify/subscribe`：存储浏览器指纹/设备标识到 Redis，便于多端同步。
- WebSocket endpoint `/api/notify/stream`：握手时校验登录态，心跳 30s。

## 消息生产与模板
- 模板存储：DB/配置文件，支持占位符（如 `${bookTitle}`）。
- 生产入口：业务事件（关注更新、评论回复、审核结果）发布领域事件 -> NotifyProducer 转成标准消息体 `{userId,type,title,content,actionUrl,channels[]}` -> 入队。
- 渲染：Sender Worker 渲染模板，按用户偏好与通道可用性下发。

## 未读计数一致性
- 写入时：消息入库后 `INCR` Redis 未读计数。
- 已读时：成功更新行数后对应 `DECR`，防并发通过行锁/乐观锁确保不为负。
- 兜底：定时任务重建未读计数（扫 DB count unread -> 写 Redis）。

## 容错与重试
- 发送失败写入 `notify.dlq`，支持手动/自动重放。
- WebSocket 推送失败标记为未送达，下次连接时补发。
- 限流：过滤相同通知在短时间内重复推送（如 10 分钟同一章节更新仅推一次）。

## 可观测性
- 指标：`notify_delivery_rate`、`notify_latency_ms`、`unread_rebuild_count`、`ws_active_conn`。
- 日志：按 `traceId` 记录发送/回执；用户侧错误码简化。
- 告警：送达率低于阈值、死信堆积、活跃连接暴跌。

## 前端接入细节
- WebSocket 断开自动重连并回退轮询未读数；心跳间隔 30s，超时关闭重连。
- UI 未读徽标基于 `/unread-count`；进入列表后调用 `/read` 或 `/read-all` 同步。
- 根据 `actionUrl` 跳转，若为空展示详情。
- 允许用户配置通知偏好（如仅站内信），前端保存设置并在订阅接口上传。
